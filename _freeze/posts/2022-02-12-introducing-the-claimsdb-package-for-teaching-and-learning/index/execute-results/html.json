{
  "hash": "a539ade8b799e9a5c3f46ebe9dd081d7",
  "result": {
    "markdown": "---\ntitle: \"Introducing the claimsdb package for teaching and learning\"\ndate: \"2022-02-12\"\ncategories: [health care, claims, Medicare, databases]\nimage: \"README-diagram.PNG\"\nexecute: \n  warning: false\n  output: true\n---\n\n\n![](README-diagram.PNG){style=\"border: 5px solid #555;\" fig-alt=\"Diagram of claims database tables with arrows to show data relationships\"}\n\nIn the fields of health informatics and health services research, health insurance claims data are a valuable resource to help answer questions about health care access and financing. However, claims data in the real world often contains both sensitive (protected health information) and proprietary (trade secrets) elements. For most students and educators seeking opportunities to learn how to use claims data, there are few available sources for practice.\n\nTo help with this problem, [**claimsdb**](https://github.com/jfangmeier/claimsdb) ðŸ“¦ provides easy access to a sample of health insurance enrollment and claims data from the [Centers for Medicare and Medicaid Services (CMS) Data Entrepreneurs' Synthetic Public Use File (DE-SynPUF)](https://www.cms.gov/Research-Statistics-Data-and-Systems/Downloadable-Public-Use-Files/SynPUFs/DE_Syn_PUF), as a set of relational tables or as an in-memory database using [DuckDB](https://duckdb.org/). All the data is contained within a single package, so users do not need to download any external data. This package is inspired by and based on the [starwarsdb](https://github.com/gadenbuie/starwarsdb) package.\n\nThe data are structured as actual Medicare claims data but are fully \"synthetic,\" after a process of alterations meant to reduce the risk of re-identification of real Medicare beneficiaries. The synthetic process that CMS adopted changes the co-variation across variables, so analysts should be cautious about drawing inferences about the actual Medicare population.\n\nThe data included in claimsdb comes from 500 randomly selected 2008 Medicare beneficiaries from Sample 2 of the DE-SynPUF, and it includes all the associated claims for these members for 2008-2009. CMS provides [resources](https://www.cms.gov/Research-Statistics-Data-and-Systems/Downloadable-Public-Use-Files/SynPUFs/DESample02), including a codebook, FAQs, and other documents with more information about this data.\n\nTo introduce claimsdb, this post covers the following topics: - Installation of the claimsdb package - How to setup a remote database with the included data - Examples of how to use claimsdb for analysis - An overview of the limitations of the data included in package\n\n## Installation and components of the *claimsdb* package\n\nYou can install the development version of claimsdb from GitHub with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"devtools\")\ndevtools::install_github(\"jfangmeier/claimsdb\")\n```\n:::\n\n\nYou can then load claimsdb alongside your other packages. We will be using the *tidyverse* packages in our later examples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(claimsdb)\n```\n:::\n\n\nThe tables are available after loading the claimsdb package. This includes a `schema` that describes each of the tables and the included variables from the [CMS DE-SynPUF](https://www.cms.gov/Research-Statistics-Data-and-Systems/Downloadable-Public-Use-Files/SynPUFs/DE_Syn_PUF). You can see that claimsdb includes five tables. One of the tables, *bene* contains beneficiary records, while the others include specific types of claims data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nschema\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 5\n  TABLE      TABLE_TITLE                                TABLE~1 UNIT_~2 PROPER~3\n  <chr>      <chr>                                      <chr>   <chr>   <list>  \n1 bene       CMS Beneficiary Summary DE-SynPUF          Synthe~ Benefi~ <tibble>\n2 carrier    CMS Carrier Claims DE-SynPUF               Synthe~ claim   <tibble>\n3 inpatient  CMS Inpatient Claims DE-SynPUF             Synthe~ claim   <tibble>\n4 outpatient CMS Outpatient Claims DE-SynPUF            Synthe~ claim   <tibble>\n5 pde        CMS Prescription Drug Events (PDE) DE-Syn~ Synthe~ claim   <tibble>\n# ... with abbreviated variable names 1: TABLE_DESCRIPTION, 2: UNIT_OF_RECORD,\n#   3: PROPERTIES\n```\n:::\n:::\n\n\nYou can access details on the variables in each of the tables like in this example with the *inpatient* table. You can see that this table contains 35 fields, including a beneficiary code to identify members across tables as well as detailed information on each inpatient claim.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nschema %>% \n  filter(TABLE == \"inpatient\") %>% \n  pull(PROPERTIES)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n# A tibble: 35 x 3\n   VARIABLE                 TYPE    DESCRIPTION                                 \n   <chr>                    <chr>   <chr>                                       \n 1 DESYNPUF_ID              string  Beneficiary Code                            \n 2 CLM_ID                   string  Claim ID                                    \n 3 SEGMENT                  numeric Claim Line Segment                          \n 4 CLM_FROM_DT              date    Claims start date                           \n 5 CLM_THRU_DT              date    Claims end date                             \n 6 PRVDR_NUM                string  Provider Institution                        \n 7 CLM_PMT_AMT              numeric Claim Payment Amount                        \n 8 NCH_PRMRY_PYR_CLM_PD_AMT numeric NCH Primary Payer Claim Paid Amount         \n 9 AT_PHYSN_NPI             string  Attending Physician National Provider Ident~\n10 OP_PHYSN_NPI             string  Operating Physician National Provider Ident~\n# ... with 25 more rows\n```\n:::\n:::\n\n\n## Access claims data as a remote database\n\nMany organizations store claims data in a remote database, so claimsdb also includes all of the tables as an in-memory DuckDB database. This can be a great way to practice working with this type of data, including building queries with dplyr code using dbplyr.\n\nTo setup the in-memory database, you need to create a database connection using `claims_connect()` and create connections to each of the tables you want to use.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dbplyr)\n\n# Setup connection to duckDB database\ncon <- claims_connect()\n\n# Setup connections to each of the enrollment and claims tables in the database\nbene_rmt <- tbl(con, \"bene\")\ninpatient_rmt <- tbl(con, \"inpatient\")\noutpatient_rmt <- tbl(con, \"outpatient\")\ncarrier_rmt <- tbl(con, \"carrier\")\npde_rmt <- tbl(con, \"pde\")\n```\n:::\n\n\nYou can then preview your connection to each of the remote tables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Preview the prescription drug event table in the database\npde_rmt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   table<pde> [?? x 8]\n# Database: DuckDB 0.3.5-dev1410 [Josh@Windows 10 x64:R 4.1.0/:memory:]\n   DESYNPUF_ID      PDE_ID    SRVC_DT    PROD_~1 QTY_D~2 DAYS_~3 PTNT_~4 TOT_R~5\n   <chr>            <chr>     <date>     <chr>     <dbl>   <dbl>   <dbl>   <dbl>\n 1 00E040C6ECE8F878 83014463~ 2008-12-20 492880~      30      30       0      10\n 2 00E040C6ECE8F878 83594465~ 2009-04-25 529590~      20      30       0       0\n 3 00E040C6ECE8F878 83144465~ 2009-09-22 000834~      80      30      40      80\n 4 00E040C6ECE8F878 83614464~ 2009-10-03 634810~      60      10       0      10\n 5 00E040C6ECE8F878 83014461~ 2009-11-16 511294~      60      30       0      20\n 6 00E040C6ECE8F878 83234464~ 2009-12-11 580160~     270      30       0      10\n 7 014F2C07689C173B 83294462~ 2009-09-14 009045~      90      30       0      60\n 8 014F2C07689C173B 83874466~ 2009-10-11 596040~      40      20       0     570\n 9 014F2C07689C173B 83314462~ 2009-11-24 510790~      30      30       0     150\n10 014F2C07689C173B 83874467~ 2009-12-29 511293~      30      30       0      10\n# ... with more rows, and abbreviated variable names 1: PROD_SRVC_ID,\n#   2: QTY_DSPNSD_NUM, 3: DAYS_SUPLY_NUM, 4: PTNT_PAY_AMT, 5: TOT_RX_CST_AMT\n```\n:::\n:::\n\n\n## Examples of using *claimsdb* for analysis\n\nTo analyze and explore the claims and beneficiary data, you can execute your own SQL code on the database using the `DBI` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDBI::dbGetQuery(\n  con, \n  paste0(\n    'SELECT \"DESYNPUF_ID\", \"BENE_BIRTH_DT\"',\n    'FROM \"bene\"',\n    'WHERE \"BENE_SEX_IDENT_CD\" = 1.0',\n    'LIMIT 10'\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        DESYNPUF_ID BENE_BIRTH_DT\n1  001115EAB83B19BB    1939-12-01\n2  03ADA78C0FEF79F4    1923-02-01\n3  040A12AB5EAA444C    1943-10-01\n4  0507DE00BC6E6CD6    1932-07-01\n5  05672CCCED56BCAD    1937-07-01\n6  060CDE3A044F64BA    1943-02-01\n7  061B5B3D9A459675    1932-04-01\n8  08C8E0A0C6EAC884    1954-06-01\n9  09EEB5C4C4FAEF10    1935-04-01\n10 0A58C6D6B9BE67CF    1942-07-01\n```\n:::\n:::\n\n\nHowever, in the following examples, we will use the `dbplyr` package which translates dplyr code into SQL that can be executed against the database. You can see that the results below with dplyr functions match the results above that used a SQL query.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbene_rmt %>% \n  filter(BENE_SEX_IDENT_CD == 1) %>% \n  select(DESYNPUF_ID, BENE_BIRTH_DT)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 2]\n# Database: DuckDB 0.3.5-dev1410 [Josh@Windows 10 x64:R 4.1.0/:memory:]\n   DESYNPUF_ID      BENE_BIRTH_DT\n   <chr>            <date>       \n 1 001115EAB83B19BB 1939-12-01   \n 2 03ADA78C0FEF79F4 1923-02-01   \n 3 040A12AB5EAA444C 1943-10-01   \n 4 0507DE00BC6E6CD6 1932-07-01   \n 5 05672CCCED56BCAD 1937-07-01   \n 6 060CDE3A044F64BA 1943-02-01   \n 7 061B5B3D9A459675 1932-04-01   \n 8 08C8E0A0C6EAC884 1954-06-01   \n 9 09EEB5C4C4FAEF10 1935-04-01   \n10 0A58C6D6B9BE67CF 1942-07-01   \n# ... with more rows\n```\n:::\n:::\n\n\nWe can use the `show_query()` function to see the SQL code that dbplyr created and that it closely matches the SQL code above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbene_rmt %>% \n  filter(BENE_SEX_IDENT_CD == 1) %>% \n  select(DESYNPUF_ID, BENE_BIRTH_DT) %>% \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT \"DESYNPUF_ID\", \"BENE_BIRTH_DT\"\nFROM \"bene\"\nWHERE (\"BENE_SEX_IDENT_CD\" = 1.0)\n```\n:::\n:::\n\n\n### First, a note about working with dates/times in databases\n\ndbplyr is an amazing tool for working with databases, especially if you want to use many functions from the dplyr and tidyr packages. However, it does not currently have SQL translations for all functions in the tidyverse family of packages. For example, the `lubridate` package's date and time functions work on local dataframes but cannot be translated to work on remote tables at this time. In the example below, you can see that the lubridate function `year()` (for parsing the year from a date) works on the local dataframe but generates an error on the remote table with the same data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbene %>% \n  transmute(\n    DESYNPUF_ID,\n    BENE_BIRTH_DT,\n    BIRTH_YEAR = lubridate::year(BENE_BIRTH_DT)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 998 x 3\n   DESYNPUF_ID      BENE_BIRTH_DT BIRTH_YEAR\n   <chr>            <date>             <dbl>\n 1 001115EAB83B19BB 1939-12-01          1939\n 2 0018A1975BC0EE4F 1935-11-01          1935\n 3 00E040C6ECE8F878 1932-11-01          1932\n 4 014F2C07689C173B 1935-07-01          1935\n 5 029A22E4A3AAEE15 1921-05-01          1921\n 6 03410742A11DDC52 1943-07-01          1943\n 7 03ADA78C0FEF79F4 1923-02-01          1923\n 8 040A12AB5EAA444C 1943-10-01          1943\n 9 043AAAE41C9A37B7 1924-03-01          1924\n10 0507DE00BC6E6CD6 1932-07-01          1932\n# ... with 988 more rows\n```\n:::\n\n```{.r .cell-code}\nbene_rmt %>% \n  transmute(\n    DESYNPUF_ID,\n    BENE_BIRTH_DT,\n    BIRTH_YEAR = lubridate::year(BENE_BIRTH_DT)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 3]\n# Database: DuckDB 0.3.5-dev1410 [Josh@Windows 10 x64:R 4.1.0/:memory:]\n   DESYNPUF_ID      BENE_BIRTH_DT BIRTH_YEAR\n   <chr>            <date>             <dbl>\n 1 001115EAB83B19BB 1939-12-01          1939\n 2 0018A1975BC0EE4F 1935-11-01          1935\n 3 00E040C6ECE8F878 1932-11-01          1932\n 4 014F2C07689C173B 1935-07-01          1935\n 5 029A22E4A3AAEE15 1921-05-01          1921\n 6 03410742A11DDC52 1943-07-01          1943\n 7 03ADA78C0FEF79F4 1923-02-01          1923\n 8 040A12AB5EAA444C 1943-10-01          1943\n 9 043AAAE41C9A37B7 1924-03-01          1924\n10 0507DE00BC6E6CD6 1932-07-01          1932\n# ... with more rows\n```\n:::\n:::\n\n\nFortunately, dbplyr allows you pass along SQL functions in your dplyr code, and it will include these functions in the generated query. For date/time functions, we need to consult the [documentation](https://duckdb.org/docs/sql/functions/date) from DuckDB on date functions. To parse a part of a date (e.g., the year), we need to use the `date_part()` function for DuckDB.\n\nThe function to do this task may vary across database backends, so if you are doing this with a different database (Oracle, SQL Server, etc.), you will need to read the documentation for that database management system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbene_rmt %>% \n  transmute(\n    DESYNPUF_ID,\n    BENE_BIRTH_DT,\n    BIRTH_YEAR = date_part('year', BENE_BIRTH_DT)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 3]\n# Database: DuckDB 0.3.5-dev1410 [Josh@Windows 10 x64:R 4.1.0/:memory:]\n   DESYNPUF_ID      BENE_BIRTH_DT BIRTH_YEAR\n   <chr>            <date>             <dbl>\n 1 001115EAB83B19BB 1939-12-01          1939\n 2 0018A1975BC0EE4F 1935-11-01          1935\n 3 00E040C6ECE8F878 1932-11-01          1932\n 4 014F2C07689C173B 1935-07-01          1935\n 5 029A22E4A3AAEE15 1921-05-01          1921\n 6 03410742A11DDC52 1943-07-01          1943\n 7 03ADA78C0FEF79F4 1923-02-01          1923\n 8 040A12AB5EAA444C 1943-10-01          1943\n 9 043AAAE41C9A37B7 1924-03-01          1924\n10 0507DE00BC6E6CD6 1932-07-01          1932\n# ... with more rows\n```\n:::\n:::\n\n\n### Example 1: *which members had the highest prescription drug costs for 2008?*\n\nFor this first example, we are going to identify the beneficiaries with the highest total prescription drug costs in 2008. We need to use the *pde* table that has claims on prescription drug events and the *bene* table that has beneficiary records. We create an object that is the aggregated costs for prescription drugs at the beneficiary level in 2008. Note that we had to use `date_part()` to parse the year from the service date.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate rx costs for utilizing members in 2008\nrx_costs_rmt <- pde_rmt %>% \n  mutate(BENE_YEAR = date_part('year', SRVC_DT)) %>% \n  filter(BENE_YEAR == 2008) %>% \n  group_by(BENE_YEAR, DESYNPUF_ID) %>% \n  summarize(TOTAL_RX_COST = sum(TOT_RX_CST_AMT, na.rm = T), .groups = \"drop\") %>% \n  ungroup()\n\nrx_costs_rmt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 3]\n# Database: DuckDB 0.3.5-dev1410 [Josh@Windows 10 x64:R 4.1.0/:memory:]\n   BENE_YEAR DESYNPUF_ID      TOTAL_RX_COST\n       <dbl> <chr>                    <dbl>\n 1      2008 00E040C6ECE8F878            10\n 2      2008 03ADA78C0FEF79F4          5020\n 3      2008 040A12AB5EAA444C           120\n 4      2008 043AAAE41C9A37B7           810\n 5      2008 05672CCCED56BCAD             0\n 6      2008 061B5B3D9A459675           270\n 7      2008 08BB74BA9DFD5C06            20\n 8      2008 08C8E0A0C6EAC884          5860\n 9      2008 09EEB5C4C4FAEF10          1590\n10      2008 0A58C6D6B9BE67CF           930\n# ... with more rows\n```\n:::\n:::\n\n\nThen we join the aggregated cost data to the beneficiary table. This is necessary because the *pde* table does not include beneficiaries who didn't use any prescription drugs. After joining the table we reassign missing cost data to zero for those beneficiaries with no utilization. We can then use `collect()` to retrieve the results as a local dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Join the rx costs data to the beneficiary file and include members with no costs\nrx_bene_rmt <- bene_rmt %>% \n  filter(BENE_YEAR == 2008) %>% \n  select(\n    BENE_YEAR,\n    DESYNPUF_ID\n  ) %>% \n  left_join(\n    rx_costs_rmt, by = c(\"BENE_YEAR\", \"DESYNPUF_ID\")\n  ) %>% \n  mutate(TOTAL_RX_COST = ifelse(is.na(TOTAL_RX_COST), 0, TOTAL_RX_COST)) %>% \n  arrange(desc(TOTAL_RX_COST))\n\nrx_bene_rmt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:     SQL [?? x 3]\n# Database:   DuckDB 0.3.5-dev1410 [Josh@Windows 10 x64:R 4.1.0/:memory:]\n# Ordered by: desc(TOTAL_RX_COST)\n   BENE_YEAR DESYNPUF_ID      TOTAL_RX_COST\n       <dbl> <chr>                    <dbl>\n 1      2008 484FAAB99C7F90F2         10410\n 2      2008 1187122DCAD04B48          9300\n 3      2008 5199E41C3B2B36AD          9110\n 4      2008 801D1702FC0C105F          8210\n 5      2008 92158DA24D7A8799          7910\n 6      2008 A705B8508EB5747D          7380\n 7      2008 A9142A5D9895479C          6780\n 8      2008 D20C21DD9F8177D0          6590\n 9      2008 08C8E0A0C6EAC884          5860\n10      2008 EBE9CC1D92AA56C0          5690\n# ... with more rows\n```\n:::\n\n```{.r .cell-code}\n# You can use collect() to bring the results into a local dataframe\nrx_bene_df <- rx_bene_rmt %>% \n  collect()\n\nrx_bene_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 500 x 3\n   BENE_YEAR DESYNPUF_ID      TOTAL_RX_COST\n       <dbl> <chr>                    <dbl>\n 1      2008 484FAAB99C7F90F2         10410\n 2      2008 1187122DCAD04B48          9300\n 3      2008 5199E41C3B2B36AD          9110\n 4      2008 801D1702FC0C105F          8210\n 5      2008 92158DA24D7A8799          7910\n 6      2008 A705B8508EB5747D          7380\n 7      2008 A9142A5D9895479C          6780\n 8      2008 D20C21DD9F8177D0          6590\n 9      2008 08C8E0A0C6EAC884          5860\n10      2008 EBE9CC1D92AA56C0          5690\n# ... with 490 more rows\n```\n:::\n:::\n\n\n### Example 2: *what percent of beneficiaries received an office visit within 30 days of discharge from a hospital?*\n\nIn the next example, we are identifying which beneficiaries had an office visit within 30 days of being discharged. We will start with the *inpatient* table that contains records for all inpatient stays, including when a beneficiary was discharged. We create an object that includes the beneficiary ID, the discharge date, and the date 30 days after discharge. Note that for DuckDB we need to coerce \"30\" to an integer to calculate the new date.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identify all member discharge dates and the dates 30 days after discharge from the inpatient table\nip_discharges <- inpatient_rmt %>% \n  transmute(\n    DESYNPUF_ID, \n    DSCHRG_DT = NCH_BENE_DSCHRG_DT,\n    DSCHRG_DT_30 = NCH_BENE_DSCHRG_DT + as.integer(30)) %>% \n  distinct()\n\nip_discharges\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 3]\n# Database: DuckDB 0.3.5-dev1410 [Josh@Windows 10 x64:R 4.1.0/:memory:]\n   DESYNPUF_ID      DSCHRG_DT  DSCHRG_DT_30\n   <chr>            <date>     <date>      \n 1 014F2C07689C173B 2009-09-20 2009-10-20  \n 2 029A22E4A3AAEE15 2008-01-25 2008-02-24  \n 3 060CDE3A044F64BA 2008-10-18 2008-11-17  \n 4 08BB74BA9DFD5C06 2009-03-07 2009-04-06  \n 5 08BB74BA9DFD5C06 2009-03-08 2009-04-07  \n 6 08C8E0A0C6EAC884 2008-02-22 2008-03-23  \n 7 08C8E0A0C6EAC884 2009-05-28 2009-06-27  \n 8 08C8E0A0C6EAC884 2009-06-14 2009-07-14  \n 9 08C8E0A0C6EAC884 2009-07-07 2009-08-06  \n10 08C8E0A0C6EAC884 2009-08-23 2009-09-22  \n# ... with more rows\n```\n:::\n:::\n\n\nNext, we need to identify office visits from the *carrier* table. I created a vector of five office visit codes for this example. Since these codes must match the values in the \"HCPCS\" columns, we reshape the table with `pivot_longer()` then filter for the office visit codes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create vector of office visit codes\noff_vis_cds <- as.character(99211:99215)\n\n# Identify members who had an office visit from the carrier table\noff_visit <- carrier_rmt %>% \n  select(DESYNPUF_ID, CLM_ID, CLM_FROM_DT, matches(\"HCPCS\")) %>% \n  pivot_longer(cols = matches(\"HCPCS\"), names_to = \"LINE\", values_to = \"HCPCS\") %>% \n  filter(HCPCS %in% off_vis_cds) %>% \n  distinct(DESYNPUF_ID, CLM_FROM_DT) %>% \n  mutate(OFFICE_VISIT = 1)\n\noff_visit\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 3]\n# Database: DuckDB 0.3.5-dev1410 [Josh@Windows 10 x64:R 4.1.0/:memory:]\n   DESYNPUF_ID      CLM_FROM_DT OFFICE_VISIT\n   <chr>            <date>             <dbl>\n 1 00E040C6ECE8F878 2009-01-17             1\n 2 00E040C6ECE8F878 2009-07-20             1\n 3 00E040C6ECE8F878 2009-07-26             1\n 4 029A22E4A3AAEE15 2008-01-25             1\n 5 029A22E4A3AAEE15 2008-01-30             1\n 6 029A22E4A3AAEE15 2008-08-28             1\n 7 029A22E4A3AAEE15 2008-11-19             1\n 8 029A22E4A3AAEE15 2009-04-01             1\n 9 029A22E4A3AAEE15 2009-04-12             1\n10 029A22E4A3AAEE15 2009-05-13             1\n# ... with more rows\n```\n:::\n:::\n\n\nFinally, we join the office visits object to the discharges object. We can use the `sql_on` option in `left_join()` to inject some custom SQL to join when the office visit date is within 30 days of the discharge date.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Join discharges data and office visit data\ndischarge_offvis <- \n  ip_discharges %>% \n  left_join(\n    off_visit,\n    sql_on = paste0(\n      \"(LHS.DESYNPUF_ID = RHS.DESYNPUF_ID) AND\",\n      \"(RHS.CLM_FROM_DT >= LHS.DSCHRG_DT) AND\",\n      \"(RHS.CLM_FROM_DT <= LHS.DSCHRG_DT_30)\"\n      )\n  )\n\ndischarge_offvis\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 6]\n# Database: DuckDB 0.3.5-dev1410 [Josh@Windows 10 x64:R 4.1.0/:memory:]\n   DESYNPUF_ID.x    DSCHRG_DT  DSCHRG_DT_30 DESYNPUF_ID.y    CLM_FROM_DT OFFIC~1\n   <chr>            <date>     <date>       <chr>            <date>        <dbl>\n 1 029A22E4A3AAEE15 2008-01-25 2008-02-24   029A22E4A3AAEE15 2008-01-25        1\n 2 029A22E4A3AAEE15 2008-01-25 2008-02-24   029A22E4A3AAEE15 2008-01-30        1\n 3 060CDE3A044F64BA 2008-10-18 2008-11-17   060CDE3A044F64BA 2008-11-01        1\n 4 1187122DCAD04B48 2009-04-06 2009-05-06   1187122DCAD04B48 2009-04-07        1\n 5 1187122DCAD04B48 2009-04-06 2009-05-06   1187122DCAD04B48 2009-04-27        1\n 6 1187122DCAD04B48 2009-04-06 2009-05-06   1187122DCAD04B48 2009-05-04        1\n 7 12D6FF0C18764D0D 2009-05-08 2009-06-07   12D6FF0C18764D0D 2009-05-19        1\n 8 12D6FF0C18764D0D 2009-05-08 2009-06-07   12D6FF0C18764D0D 2009-05-24        1\n 9 144C187653FBBE83 2008-06-08 2008-07-08   144C187653FBBE83 2008-06-22        1\n10 202F481BD60B4F1C 2009-04-28 2009-05-28   202F481BD60B4F1C 2009-05-03        1\n# ... with more rows, and abbreviated variable name 1: OFFICE_VISIT\n```\n:::\n:::\n\n\nAfter the join is complete, we can calculate the share of discharges with a timely office visit.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Find the percent of members with a office visit within 30 days of discharge\ndischarge_offvis %>% \n  distinct(\n    DESYNPUF_ID.x,\n    DSCHRG_DT,\n    OFFICE_VISIT\n  ) %>% \n  mutate(OFFICE_VISIT = ifelse(is.na(OFFICE_VISIT), 0, OFFICE_VISIT)) %>% \n  summarize(\n    OFV_RATE = mean(OFFICE_VISIT, na.rm = T)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB 0.3.5-dev1410 [Josh@Windows 10 x64:R 4.1.0/:memory:]\n  OFV_RATE\n     <dbl>\n1    0.540\n```\n:::\n:::\n\n\n### Example 3: *how well are beneficiaries filling their hypertension drug prescriptions?*\n\nFor this final example, we need to identify hypertension medications from the *pde* table and calculate medication adherence rates for each beneficiary. To isolate the hypertension medications, we can borrow from the HEDIS medication list for ACE inhibitors and ARB medications (which are commonly used to treat hypertension). This medication list is for 2018/2019, so it likely includes new drugs that did not exist in 2008/2009 and may not include older drugs that are no longer used (ideally it's best to use external lists that match the time frame of the claims data).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhedis_wb <- tempfile()\n\ndownload.file(\n  url = \"https://www.ncqa.org/hedis-2019-ndc-mld-directory-complete-workbook-final-11-1-2018-3/\",\n  destfile = hedis_wb,\n  mode = \"wb\"\n)\n\nhedis_df <- readxl::read_excel(\n  path = hedis_wb,\n  sheet = \"Medications List to NDC Codes\"\n)\n\nhyp_ndc_df <- \n  hedis_df %>% \n  filter(`Medication List` == \"ACE Inhibitor/ARB Medications\") %>% \n  select(\n    LIST = `Medication List`,\n    PRODUCTID = `NDC Code`\n  )\n\nhyp_ndc_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,230 x 2\n   LIST                          PRODUCTID  \n   <chr>                         <chr>      \n 1 ACE Inhibitor/ARB Medications 00093512501\n 2 ACE Inhibitor/ARB Medications 00093512505\n 3 ACE Inhibitor/ARB Medications 00185005301\n 4 ACE Inhibitor/ARB Medications 00185005305\n 5 ACE Inhibitor/ARB Medications 00247213730\n 6 ACE Inhibitor/ARB Medications 00378044301\n 7 ACE Inhibitor/ARB Medications 00781189201\n 8 ACE Inhibitor/ARB Medications 13811062810\n 9 ACE Inhibitor/ARB Medications 13811062850\n10 ACE Inhibitor/ARB Medications 21695032630\n# ... with 3,220 more rows\n```\n:::\n:::\n\n\nOne of the cool features of dbplyr is that we can copy this local dataframe to the database as a temporary table using the `copy_to()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhyp_ndc_rmt <- copy_to(con, hyp_ndc_df, overwrite = T)\n\nhyp_ndc_rmt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   table<hyp_ndc_df> [?? x 2]\n# Database: DuckDB 0.3.5-dev1410 [Josh@Windows 10 x64:R 4.1.0/:memory:]\n   LIST                          PRODUCTID  \n   <chr>                         <chr>      \n 1 ACE Inhibitor/ARB Medications 00093512501\n 2 ACE Inhibitor/ARB Medications 00093512505\n 3 ACE Inhibitor/ARB Medications 00185005301\n 4 ACE Inhibitor/ARB Medications 00185005305\n 5 ACE Inhibitor/ARB Medications 00247213730\n 6 ACE Inhibitor/ARB Medications 00378044301\n 7 ACE Inhibitor/ARB Medications 00781189201\n 8 ACE Inhibitor/ARB Medications 13811062810\n 9 ACE Inhibitor/ARB Medications 13811062850\n10 ACE Inhibitor/ARB Medications 21695032630\n# ... with more rows\n```\n:::\n:::\n\n\nWith the hypertension codes in the database, we can use `inner_join()` to find the matching drugs from the *pde* table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npde_hyp_rmt <- \n  pde_rmt %>% \n  inner_join(\n    hyp_ndc_rmt, by = c(\"PROD_SRVC_ID\" = \"PRODUCTID\")\n  )\n\npde_hyp_rmt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 9]\n# Database: DuckDB 0.3.5-dev1410 [Josh@Windows 10 x64:R 4.1.0/:memory:]\n   DESYNPUF_ID   PDE_ID SRVC_DT    PROD_~1 QTY_D~2 DAYS_~3 PTNT_~4 TOT_R~5 LIST \n   <chr>         <chr>  <date>     <chr>     <dbl>   <dbl>   <dbl>   <dbl> <chr>\n 1 03ADA78C0FEF~ 83554~ 2008-02-01 510790~      30      30       0      10 ACE ~\n 2 040A12AB5EAA~ 83974~ 2009-11-27 638740~      90      30       0      10 ACE ~\n 3 043AAAE41C9A~ 83024~ 2008-08-11 002472~     200      90      10      80 ACE ~\n 4 0D540BEBC45A~ 83454~ 2009-02-18 604290~      60      90      10      10 ACE ~\n 5 0D540BEBC45A~ 83874~ 2009-06-15 661050~      30      30       0      10 ACE ~\n 6 0E0A0107787B~ 83714~ 2008-06-30 661050~     100      90      70      60 ACE ~\n 7 109D67D11477~ 83064~ 2008-11-21 134110~      30      60       0      70 ACE ~\n 8 109D67D11477~ 83034~ 2009-07-03 666850~      30      30       0      10 ACE ~\n 9 10D75CDD5B4A~ 83804~ 2008-07-01 002472~      90      90       0      10 ACE ~\n10 1183CA4884F8~ 83934~ 2009-01-25 001850~      90      20       0     110 ACE ~\n# ... with more rows, and abbreviated variable names 1: PROD_SRVC_ID,\n#   2: QTY_DSPNSD_NUM, 3: DAYS_SUPLY_NUM, 4: PTNT_PAY_AMT, 5: TOT_RX_CST_AMT\n```\n:::\n:::\n\n\nWe can now use `collect()` to retrieve the data as a local dataframe. As a dataframe, we can now use the `AdhereR` package to calculate the *medication possession ratio (MPR)* for members who filled a hypertension medication. MPR is a commonly used metric of medication adherence, measuring if beneficiaries have gaps between their prescription fills.\n\nWe can see the MPR for each member who filled one of the medications, and we can calculate the median and mean MPRs across these beneficiaries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"AdhereR\")\nlibrary(AdhereR)\n\npde_hyp_df <- pde_hyp_rmt %>% \n  collect()\n\nhyp_adhere <- CMA4(\n  data = pde_hyp_df,\n  ID.colname = 'DESYNPUF_ID',\n  event.date.colname = 'SRVC_DT',\n  event.duration.colname = 'DAYS_SUPLY_NUM',\n  date.format = \"%Y-%m-%d\"\n)\n\nhyp_adhere_cma <- hyp_adhere$CMA %>% tibble()\n\nhyp_adhere_cma\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 134 x 2\n   DESYNPUF_ID         CMA\n   <chr>             <dbl>\n 1 03ADA78C0FEF79F4 0.0411\n 2 040A12AB5EAA444C 0.0411\n 3 043AAAE41C9A37B7 0.123 \n 4 0D540BEBC45ADCA7 0.164 \n 5 0E0A0107787B32AA 0.123 \n 6 109D67D114778917 0.123 \n 7 10D75CDD5B4AD3B0 0.123 \n 8 1183CA4884F8A0A8 0.0274\n 9 11C45CF0DDD03ACE 0.0822\n10 1226AD9944384B64 0.0411\n# ... with 124 more rows\n```\n:::\n\n```{.r .cell-code}\nhyp_adhere_cma %>% \n  summarize(\n    median_mpr = median(CMA),\n    mean_mpr = mean(CMA)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 2\n  median_mpr mean_mpr\n       <dbl>    <dbl>\n1     0.0411   0.0848\n```\n:::\n:::\n\n\n## Data Limitations\n\nWhile data included in claimsdb is useful for many types of analyses, it does include a few notable limitations. - As mentioned earlier, the data is a small sample (500 beneficiaries) and is not intended to be representative of the Medicare population. In addition, the data is synthetic and should not be used for drawing inferences on the Medicare population. - Since the data is more than 10 years old, it doesn't capture newer medications or procedures. It also includes procedure codes that have been retired or replaced. This is a challenge when applying external code lists that are much newer. - The diagnosis fields in the data use the International Classification of Diseases, Ninth Revision (ICD-9), but the United States converted to ICD-10 in 2015. If you are interesting in a mapping between ICD-9 and ICD-10, CMS has [resources](https://www.cms.gov/Medicare/Coding/ICD10/Archive-ICD-10-CM-ICD-10-PCS-GEMs) to consider. - The Medicare population is mostly Americans aged 65 and over, so the data will not have claims on certain specialties such as pediatrics or maternity care.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}